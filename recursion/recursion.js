/*
* LeetCode：
* 题号：93
* 标题：复原IP地址
* 题目：有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），
* 整数之间用 '.' 分隔。
*
* 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，
* 但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。
*
* 示例：
* 输入：s = "25525511135"
* 输出：["255.255.11.135","255.255.111.35"]
*
* 输入：s = "1111"
* 输出：["1.1.1.1"]
*
* */

// 解法 1：递归子串 + dfs
var restoreIpAddresses1 = function(s) {
    var result = [];
    var range = function (tar, sub) {
        // 边界条件：IP 地址的最大长度为 12
        if (sub.length < 13 ) {
            // 4 组字符收集完毕且 s 中的字符全部用完
            if (tar.length === 4 && tar.join('') === s) {
                result.push(tar.join('.'));
            } else {
                // 每次递归收集某一组字符时，都有 3 种可能，且要考虑 s 长度小于 12 时的情况
                for (var i = 0, len = Math.min(3, sub.length); i < len; i++) {
                    var char = sub.slice(0, i + 1);
                    if (+char < 256) {
                        // 边界条件：0xx 或 0x 为非法字符
                        !(char.length > 1 && char[0] === '0') && range(tar.concat(char), sub.slice(i + 1));
                    }
                }
            }
        }
    };
    range([], s);
    return result;
};

// 解法 2：回溯下标 + dfs
var restoreIpAddresses2 = function(s) {
    var result = [];
    var dfs = function (tar, index) {
        // 4 组字符收集完毕且 s 中的字符全部用完
        if (tar.length === 4 && index === s.length) {
            result.push(tar.join('.'));
            return;
        }

        // 边界条件：4 组字符收集完毕但 s 中的字符没有用完
        if (tar.length === 4 && index < s.length) return;

        for (var i = 1; i < 4; i++) {
            // 每次递归收集某一组字符时，都有 3 种可能，且要考虑 s 长度小于 12 时的情况
            if (index + i > s.length) return;
            var char = s.slice(index, index + i);

            // 边界条件：0xx 或 0x 为非法字符，且一组 IP 值应小于 256
            if (+char > 255 || (char.length > 1 && char[0] === '0')) return;
            dfs(tar.concat(char), index + i);
        }
    };
    dfs([], 0);
    return result;
};

/*
* 两种方法都是递归，只不过解法 2 中有多个 return，更符合回溯（特殊的递归）的特征；
* 无论是递归下标还是子串，只要在循环内能取到字符即可；
* */

/*
 * 思路:
 *
 * 做第一步时我们有几种 选择 ？以 "25525511135" 为例：
 * 选 "2" 作为第一个片段
 * 选 "25" 作为第一个片段
 * 选 "255" 作为第一个片段
 * 可以选择切出三种长度，接下来，切第二个片段，又面临三种选择。
 * 约束限制了我们的搜索分支，这道题的约束条件是：
 * 这会像一棵树一样向下分支，我们用 DFS 去遍历所有选择，并且是回溯，为什么是回溯？
 * 因为某一步的选择可能来到一个错误的状态，得不到正确的结果，不要往下做了，撤销最后一个选择，回到选择前的状态，去试另一个选择。
 * 有一个「选择、探索、撤销选择」的过程。好，我们现在讲完回溯的第一个要点——选择。
 *
 * 回溯的要点二——约束
 * 一个片段的长度是 1~3
 * 片段的值范围是 0~255
 * 不能是 "0x"、"0xx" 形式（这个是测试用例告诉我们的）
 * 我们要用这些约束在 DFS 中充分地剪枝，去掉一些选择，避免去搜索一些不会产生正确答案的分支。
 *
 * 回溯的要点三——目标
 * 目标是什么，决定了 DFS 什么时候捕捉答案，什么时候砍掉死支，不继续走了返回出来。
 * 我们目标是生成 4 个有效片段，并且要耗尽 IP 字符串的字符。
 * 当遍历的节点满足该条件时，说明生成了一个有效组合，推入结果数组，回溯，继续探索。
 * 生成了4个有效片段，但没耗尽字符，则不是有效组合，不继续往下递归，返回，提前回溯。
 *
 * 定义 dfs 函数
 * dfs 函数传什么？也就是，用什么描述一个节点的状态？
 * 我们选择切出一个长度的片段后，剩余的子串继续递归，我们可以传子串，也可以传指向起始位置的指针，加上当前已经生成的片段数组，作为描述节点的状态。
 * dfs 函数做的事：「按一定规则，切割从指针 start 开始的子串」。
 *
 * 关于回溯的知识：
 * https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html
 */