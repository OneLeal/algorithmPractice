/*
* LeetCode：
* 题号：93
* 标题：复原IP地址
* 题目：有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），
* 整数之间用 '.' 分隔。
*
* 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，
* 但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。
*
* 示例：
* 输入：s = "25525511135"
* 输出：["255.255.11.135","255.255.111.35"]
*
* 输入：s = "1111"
* 输出：["1.1.1.1"]
*
* */

// 递归，但不回溯，枚举出所有可能并穷尽执行循环次数
function restoreIpAddresses(s) {
    var result = [];

    function search(cur, sub){
        // 当字符串大于12时肯定不能生成一个合法的IP地址
        if(sub.length > 12){
            return;
        }

        // 当当前数组中元素为4且拼接起来恰好需要处理的字符串，则将其加入result数组
        if(cur.length === 4 && cur.join('') === s){
            result.push(cur.join('.'));
        } else {
            // 否则，分别取出代码前1、2、3位进行递归处理
            // 由于剩余的字符串长度不一定大于等于3，所以对于长度还需要进行最小值的判断
            for(var i = 0, length = Math.min(3, sub.length); i < length; i++){
                var temp = sub.slice(0, i + 1);
                // 若数值大于255，则不可能形成合法IP地址
                if(+temp < 256){
                    // 分割出的字符串若长度大于1，则第一位不允许为0
                    if(temp.length > 1 && temp[0] === '0'){
                        continue;
                    }
                    search([...cur, temp], sub.slice(i + 1));
                }
            }
        }
    }
    search([], s);
    return result;
}

// 回溯 + DFS（depth first search 深度优先搜索）
const restoreIpAdd = (s) => {
    const res = [];

    // 复原从start开始的子串
    const dfs = (subRes, start) => {
        // 满4段，且用光所有字符
        if (subRes.length == 4 && start == s.length) {
            res.push(subRes.join('.'));     // 4段拼成字符串 推入结果数组
            return;                        // 指针已经到头了，返回
        }

        // 满4段，但还没用光字符,直接返回
        if (subRes.length == 4 && start < s.length) {
            return;
        }

        // 三种长度的选择
        for (let len = 1; len <= 3; len++) {
            if (start + len - 1 >= s.length) return;     // 指针超出边界了
            if (len != 1 && s[start] == '0') return;     // 不能是0x、0xx

            const str = s.substring(start, start + len); // 当前选择切出的片段
            if (len == 3 && +str > 255) return;          // 不能超过 255

            subRes.push(str);                 // 作出选择
            dfs(subRes, start + len);   // 基于这种选择，向下探索
            subRes.pop();                     // 撤销最后的选择，回到之前的状态
        }
    };

    dfs([], 0);
    return res;

};

/*
 * 思路:
 *
 * 做第一步时我们有几种 选择 ？以 "25525511135" 为例：
 * 选 "2" 作为第一个片段
 * 选 "25" 作为第一个片段
 * 选 "255" 作为第一个片段
 * 可以选择切出三种长度，接下来，切第二个片段，又面临三种选择。
 * 约束限制了我们的搜索分支，这道题的约束条件是：
 * 这会像一棵树一样向下分支，我们用 DFS 去遍历所有选择，并且是回溯，为什么是回溯？
 * 因为某一步的选择可能来到一个错误的状态，得不到正确的结果，不要往下做了，撤销最后一个选择，回到选择前的状态，去试另一个选择。
 * 有一个「选择、探索、撤销选择」的过程。好，我们现在讲完回溯的第一个要点——选择。
 *
 * 回溯的要点二——约束
 * 一个片段的长度是 1~3
 * 片段的值范围是 0~255
 * 不能是 "0x"、"0xx" 形式（这个是测试用例告诉我们的）
 * 我们要用这些约束在 DFS 中充分地剪枝，去掉一些选择，避免去搜索一些不会产生正确答案的分支。
 *
 * 回溯的要点三——目标
 * 目标是什么，决定了 DFS 什么时候捕捉答案，什么时候砍掉死支，不继续走了返回出来。
 * 我们目标是生成 4 个有效片段，并且要耗尽 IP 字符串的字符。
 * 当遍历的节点满足该条件时，说明生成了一个有效组合，推入结果数组，回溯，继续探索。
 * 生成了4个有效片段，但没耗尽字符，则不是有效组合，不继续往下递归，返回，提前回溯。
 *
 * 定义 dfs 函数
 * dfs 函数传什么？也就是，用什么描述一个节点的状态？
 * 我们选择切出一个长度的片段后，剩余的子串继续递归，我们可以传子串，也可以传指向起始位置的指针，加上当前已经生成的片段数组，作为描述节点的状态。
 * dfs 函数做的事：「按一定规则，切割从指针 start 开始的子串」。
 *
 * 关于回溯的知识：
 * https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html
 */